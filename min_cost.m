
function phi = min_cost_test(T_1, params)

    % Computes the cost of optimial T_1
   % Total_Emission_optT_1 <= p  % x rewards


 % Unpack parameters
T = params.T;      T0 = params.T0;      alpha = params.a;
delta_1 = params.d1;     delta_2 = params.d2;      z = params.z;   n = params.n;

u0 = params.u0;     v0 = params.v0;      
u1 = params.u1;     v1 = params.v1;

o  = params.O;      co = params.co;      ct = params.ct;
ch = params.ch;     cd = params.cd;      cs = params.cs;    cl = params.cl;

eo = params.co_tilde; eh = params.ch_tilde; ed = params.cd_tilde;
x = params.x;       y = params.y;        p = params.p;
   


M = - (u0 ./ z) + (v0 ./ z.^2) - (v1 ./ z^2) .* exp(z.* delta_2)...
- (v0 ./ z.^2).* exp(z .* delta_1) +  (( ((u1 - v1.*(T_1))/z)) ...
    + ((v1/z.^2))).* exp(z.*(T_1)) ;

R =  ((u1./ n) + (v1 ./ n^2)) .* (1- exp(n .* ((T_1) - T))) ...
    + (v1./n) .* ((T_1).* exp(n .* (T_1-T)) -T );

Gc = ( (co .* T0) ./ alpha ) .* (M + R);

Tc = ct .* (M+R);

Hc  = ch .* ( (((u1 - (v1 .* T_1)) ./ z.^2 ) + (v1 ./z.^3)) .* exp(z.*T_1) ...
        - (v0 ./ z.^3) .* exp(z.* delta_1)...
      - (v1./z.^3) .* exp(z.* delta_2)...
       + (v0./z.^3)...
       - (u0 ./ z.^2) ...
      + (v0.* delta_1.^2)./ (2.*z)  ...
      + (v1./ (2.*z)) .* ( (T_1).^2 + delta_2.^2 ) ...
      - (u1 .* (T_1))/z );

Dc = cd .* ( ( ((u1 - v1 .* (T_1)) ./ z ) + (v1 ./z.^2) ) .* exp(z.*(T_1)) ... 
                 - (v0./z.^2) .* exp(z.* delta_1) ...
                 - (v1./z.^2) .* exp(z.* delta_2) ...
                  + (v0./z.^2) ... 
                 - (u0/z) ...
                 + (v0.*delta_1.^2) ./ (2)  ...
                 + (v1./ (2)) .* ( (T_1).^2 + delta_2.^2 ) ...
                 - (u1 .* (T_1) ) ) ;


Sc = cs .* ( ((u1 ./ n.^2) +  ((2.*v1) ./ n.^3 ))  * (1 - exp( n .* ((T_1)- T) ) ) ...
             + ((u1 ./ n) +  ((v1)/n.^2 ) ).*( (T_1) - T ).*exp( n .* ((T_1)- T) ) ...
             + (v1./n).*(T - (T_1)).*(T_1).*exp(n.* ((T_1)- T)) ...
             - (v1 ./ n.^2).* (T - (T_1).* exp(n.* ((T_1)- T))) ) ;

Lc = cl .* ( u1 .* (T- (T_1)) ...
            - (v1 ./ 2) .* (T.^2 - (T_1).^2) ...
            - ( (u1 ./ n) - ((v1 .* T ) ./ n) + (v1 ./n.^2) )  ...
            + ( (u1 ./ n) - ((v1 .* (T_1) ) ./ n) + (v1 ./n.^2) ).*exp(n.* ((T_1) - T)) );




Emissions = (1 ./ T) .* ( (((eo.*T0)./alpha) + (eh ./ z) +ed) .* ...
                       ((( ((u1 - v1.*(T_1))/z)) + ((v1/z.^2))).* exp(z.*(T_1))  ...
                       - (v0 ./ z.^2).* exp(z .* delta_1) ...
                       - (v1 ./ z^2) .* exp(z.* delta_2) ...
                        + (v0 ./ z.^2) ...
                        - (u0 ./ z) )...
                        + (eh ./ z + ed) .* ((v0 .* delta_1.^2) ./2 + v1 ./2  .*((T_1).^2 + delta_2.^2) -u1.*(T_1)) ... 
                        + ((eo.*T0)./alpha) .* R ) ;


if isscalar(Emissions)
    if Emissions <= p
        k = x;
        tariff = x * (p - Emissions);
    else
        k = y;
        tariff = y * (Emissions - p);
    end
else
    error('Emissions is non-scalar. Use vectorized logic instead.');
end


phi = (1./T) .* (o + Gc + Tc + Hc + Dc + Sc + Lc) + tariff; 

end


